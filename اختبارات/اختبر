#!/usr/bin/env python

import os
import re
import json  # TODO: use yaml instead
import subprocess
import traceback
from os import path, sys

__dirname__ = path.abspath(path.dirname(__file__))


def print_help():
    help_msg = """
Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: Ø§Ø¬Ø±Ø§Ø¡_Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª [--Ù…Ø³Ø§Ø¹Ø¯Ø©] [--ØªÙƒÙ…ÙŠÙ„] [--Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯-ÙÙ‚Ø·] [--ØªØ¬Ø¯ÙŠØ¯]
                    [--Ù…Ø³Ø§Ø± Ù…Ø³Ø§Ø±]

Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù„Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù.

Ø£ÙØ³Ù’Ù†Ø§Ø¯ ØºÙŠØ± Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:
    --Ù…Ø³Ø§Ø¹Ø¯Ø©, -Ù…          Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù‡Ø°Ù‡
    --ØªÙƒÙ…ÙŠÙ„, -Ùƒ           Ø¨Ø§Ù†ØªØ§Ø¬ Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ù…Ù† Ø®Ù„Ø§Ù„ Ù…Ø§ ÙŠØ­Ø¯Ø« ÙØ¹Ù„Ø§
                            Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙˆØªÙ†ÙÙŠØ° Ø§Ù„ÙƒÙˆØ¯
    --Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯-ÙÙ‚Ø·, -Ù‚     Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø§Ù„Ø®ÙØ±Ø¬ Ø£Ùˆ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
    --ØªØ¬Ø¯ÙŠØ¯, -Ø¬           Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù†ØªØ§Ø¬ ÙƒÙ„ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ ÙˆØ¥Ù‡Ù…Ø§Ù„ Ø§Ù„Ù‚Ø¯ÙŠÙ…. Ù‡Ø°Ù‡
                            Ø§Ù„Ø£Ù…Ø± Ù„Ø§Ø¨Ø¯ Ø£Ù† ØªÙƒÙˆÙ† ÙˆØ§Ø¹ÙŠØ§ Ø¨ØªØ¨Ø¹Ø§ØªÙ‡
    --Ù…Ø³Ø§Ø± Ù…Ø³Ø§Ø±, -Ø³ Ù…Ø³Ø§Ø±  ØªØ­Ø¯ÙŠØ¯ Ù…Ø³Ø§Ø± Ù„Ø¬Ù…Ø¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù…Ù†Ù‡ ÙˆÙ…Ù† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
                            Ø¨Ø¯Ø§Ø®Ù„Ø©
    """

    print(help_msg)


def print_title(*lines, level=1, indent=None,
                top_line=True, bottom_line=True,
                file=sys.stdout, align="center",
                min_width=35, max_width=0):
    """
    print something like this, with customizations like `indent` and `level`:
    ---------------------------
                        Ù‡Ø°Ø§ Ø³Ø·Ø±
    ---------------------------
    """
    try:
        term_w = os.get_terminal_size().columns
    except:
        term_w = 100000000
    # min width is 35 and max width is term_w, otherwise the width will be the max length of `lines`
    width = min(term_w, max(min_width, *map(lambda l: len(l), lines)))
    # total printed line width has to be less than the terminal width
    if indent:
        width = width if len(indent) + width < term_w else term_w - len(indent)
    else:
        width = width if width < term_w else term_w
    levels = ["=", "-", "."]
    if type(level) == int:
        level = levels[level-1]
    if indent == None:
        if term_w < 200:
            a = term_w - width
            # `>> 1` means divide by 2 and truncate, numbers here are experimental, nothing make sense
            indent = ((a >> 1) - 5) * ' ' if a > 10 else ''
        else:
            indent = " " * 15
    if not len(indent) < term_w - 10:
        raise Exception("Indentation must be smaller than term width by more than 10 chars")

    def print_these_lines():
        nonlocal max_width
        max_width = max_width or term_w - len(indent)
        for l in lines:
            # if the length of a line is greater than term_w,
            # split it into smaller lines
            if len(l) > max_width:
                ll = []
                while l:
                    ll.append(l[0:max_width])
                    l = l[max_width:]
                l = ll
            l = [l] if type(l) != list else l
            for ll in l:
                indent_to_center_text = \
                    (width - len(ll) >> 1) * " " if align == "center" else \
                    (width - len(ll)) * " " if align == "end" else ""
                print(indent + indent_to_center_text + ll, file=file)

    if top_line:
        print(indent + level * width, file=file)
    print_these_lines()
    if bottom_line:
        print(indent + level * width, file=file)


def print_indented(text, indent="", file=sys.stdout):
    """
    put intial indent to the text and print the indented text
    """
    lines = str(text).split("\n")
    try:
        term_w = os.get_terminal_size().columns
    except:
        term_w = 100000000
    max_width = term_w - len(indent)
    for l in lines:
        # if the length of a line is greater than term_w,
        # split it into smaller lines
        if len(l) > max_width:
            ll = []
            while l:
                ll.append(l[0:max_width])
                l = l[max_width:]
            l = ll
        l = [l] if type(l) != list else l
        for ll in l:
            print(indent + ll, file=file)


def print_err(*msgs):
    """
    print to the STDERR
    """
    print(*msgs, file=sys.stderr)


def is_equal(obj1, obj2):
    if type(obj1) == list and type(obj2) == list:
        for i in range(len(obj1)):
            if not is_equal(obj1[i], obj2[i]):
                return False
        return True
    elif type(obj1) == dict and type(obj2) == dict:
        for p in obj1:
            if not is_equal(obj1.get(p), obj2.get(p)):
                return False
        return True

    return obj1 == obj2


def run(cmd, return_prcss=False, inputs=None):
    process = subprocess.Popen(cmd, shell=True,
                               stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if return_prcss:
        return process
    if inputs:
        stdouts = []
        stderrs = []
        for i in inputs:
            out, err = process.communicate(i.encode())
            stdouts.append(out.decode())
            stderrs.append(err.decode())
        return stdouts, stderrs, process.returncode
    out, err = process.communicate()
    return out.decode(), err.decode(), process.returncode


def get_tests(directory='Ø£ÙƒÙˆØ§Ø¯', clean=False, fill=False):
    tests = []
    tree = os.walk(directory)  # top-down tree
    for (full_path, dirs, files) in tree:
        full_path = path.abspath(full_path)
        alif_files = filter(lambda f: re.compile(
            r'.(Ø£Ù„Ù|alif)$').findall(f), files)
        for f in alif_files:
            name = re.compile(r'(.*)\.(?:Ø£Ù„Ù|alif)$').findall(f)[0]
            expect_file = None
            if not clean:
                expect_file = path.join(full_path, f"{name}_ØªÙˆÙ‚Ø¹.json")
                expect_file = expect_file if path.exists(expect_file) else None
            if fill and expect_file:
                continue
            code_file = path.join(full_path, f)
            t = {
                "full_path": full_path,
                "tests": [{
                    "name": name, "code_file": code_file,
                    "expect_file": expect_file}]
            }
            tests.append(t)

        if dirs:
            for d in dirs:
                sub_tests = get_tests(d)
                tests.extend(sub_tests)

    return tests


def test_unit(tt, full_path, syntax_only=False):
    SYNTAX_ONLY = "<Ù‚ÙˆØ§Ø¹Ø¯ ÙÙ‚Ø·>"
    name = tt.get('name')
    code_file = tt.get("code_file")
    expect_file = tt.get("expect_file")
    exec_file = path.join(full_path, f"{name}_ØªÙ†ÙÙŠØ°ÙŠ")
    log_file = path.join(full_path, f"{name}_Ø³Ø¬Ù„")
    code_file_rel_path = path.relpath(code_file, start=__dirname__)
    expect_file_rel_path = path.relpath(expect_file, start=__dirname__)
    exec_file_rel_path = path.relpath(exec_file, start=__dirname__)
    log_file_rel_path = path.relpath(log_file, start=__dirname__)

    def print_full_test_details_due_to_err(indent=" "*8):
        print_title(f"ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø®Ø·Ø£", indent=indent, level=3)
        exception_str = "".join(traceback.format_exception(*sys.exc_info()))
        print_indented(exception_str, indent=indent)
        # is exec fle generated
        print_title(f"ØªÙØ§ØµÙŠÙ„ Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù", indent=indent, level=3)
        alif_details, alif_errors, rc = run("alif")
        if rc:
            print_indented(alif_errors, indent=indent)
        else:
            print_indented(alif_details, indent=indent)
        # is exec fle generated
        print_title(
            f"Ù‡Ù„ Ø§Ù†ØªØ¬ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠ ({exec_file_rel_path}):", indent=indent, level=3)
        print_indented(path.exists(exec_file), indent=indent)
        # print tt
        print_title("Ù‡Ø°Ù‡ Ù‡ÙŠ ØªÙØ§ØµÙ„ÙŠ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", indent=indent, level=3)
        tt_str = json.dumps(tt, indent=2, ensure_ascii=False)
        print_indented(tt_str, indent=indent)
        # print content of `log_file`
        print_title(f"Ù…Ù„Ù Ø§Ù„Ø³Ø¬Ù„ ({log_file_rel_path}):",
                    indent=indent, level=3)
        if path.exists(log_file):
            with open(log_file, "r") as f:
                content = f.read()
                print_indented(content, indent=indent)
        else:
            print_indented("<ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯>", indent=indent)
        # print content of `expect_file`
        print_title(
            f"Ù…Ù„Ù Ø§Ù„ØªÙˆÙ‚Ø¹ ({expect_file_rel_path}):", indent=indent, level=3)
        if expect_file and path.exists(expect_file):
            with open(expect_file, "r") as f:
                content = f.read()
                print_indented(content, indent=indent)
        else:
            print_indented("<ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯>", indent=indent)

    def do_test():
        nonlocal expect_file
        execs_stds = None
        execs_inputs = None
        compi_inputs = None
        if expect_file:
            with open(expect_file, "r") as f:
                expected_behaviour = json.loads(f.read())
                compi_inputs = expected_behaviour.get('ØªØ¬Ù…ÙŠØ¹').get('Ø¯Ø®Ù„')
                expected_exec = expected_behaviour.get('ØªÙ†ÙÙŠØ°')
                if expected_exec and expected_exec != SYNTAX_ONLY:
                    execs_inputs = map(lambda r: r.get('Ø¯Ø®Ù„'), expected_exec)
                if syntax_only:
                    expected_behaviour["ØªÙ†ÙÙŠØ°"] = SYNTAX_ONLY

        syntax_only_arg = '--syntax-only' if syntax_only else ''
        compile_stdout, compile_stderr, compile_exitcode = \
            run(f"alif '{code_file}' {syntax_only_arg} --o '{exec_file}' --log-json '{log_file}'",
                inputs=compi_inputs)
        if not compile_exitcode and not syntax_only:
            execs_stds = \
                map(lambda i: (i, *run(f"'{exec_file}'", inputs=i)), execs_inputs) \
                if execs_inputs else [(None, *run(f"'{exec_file}'"))]

        logs = None
        if compile_exitcode:
            with open(log_file, "r") as f:
                logs = json.loads(f.read())

        real_behaviour = {
            "ØªÙ†ÙÙŠØ°": [*map(lambda stds: {
                "Ø±Ù…Ø²_Ø§Ù„Ø®Ø±ÙˆØ¬": stds[3],
                "Ø¯Ø®Ù„": stds[0],
                "Ø®Ø±Ø¬": stds[1],
                "Ø®Ø·Ø£": stds[2]
            }, execs_stds)]
            if execs_stds else SYNTAX_ONLY
            if syntax_only else None,  # if no error occured
            "ØªØ¬Ù…ÙŠØ¹": {
                "Ø±Ù…Ø²_Ø§Ù„Ø®Ø±ÙˆØ¬": compile_exitcode,
                "Ø¯Ø®Ù„": compi_inputs,
                "Ø®Ø±Ø¬": compile_stdout,
                "Ø®Ø·Ø£": compile_stderr,
                "Ø³Ø¬Ù„": logs
            }
        }

        # compare expected and real behaviours and return the state
        # of the test:
        #   - if the expect_file doesn't exists, generate it and return
        #   - if a syntax-only test was done before (compilation state only known),
        #       and now a complete test is running, test the compilation only and
        #       change the execution state if only the test pass
        #   - otherwise compare both behaviours' exec and compi behaviours

        def print_failure_details(indent=" "*8):
            real_behaviour_str = json.dumps(real_behaviour,
                                            indent=2, ensure_ascii=False)
            expected_behaviour_str = json.dumps(expected_behaviour,
                                                indent=2, ensure_ascii=False)
            print_title("Ù…Ø§ Ø­Ø¯Ø« ÙØ¹Ù„Ø§", indent=indent, level=3)
            # put `indent` as intial indentation
            print_indented(real_behaviour_str, indent=indent)
            print_title("Ù…Ø§ ÙƒØ§Ù† Ù…ÙØªÙˆÙ‚Ø¹Ø§", indent=indent, level=3)
            print_indented(expected_behaviour_str, indent=indent)

        if not expect_file:
            expect_file = path.join(full_path, f"{name}_ØªÙˆÙ‚Ø¹.json")
            with open(expect_file, "w") as f:
                f.write(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
            print("    ğŸ“: ", code_file_rel_path)
        elif not syntax_only and expected_behaviour.get("ØªÙ†ÙÙŠØ°") == SYNTAX_ONLY:
            equal = is_equal(real_behaviour.get("ØªØ±Ø¬Ù…Ø©"),
                             expected_behaviour.get("ØªØ±Ø¬Ù…Ø©"))
            if equal:
                with open(expect_file, "w") as f:
                    f.write(json.dumps(real_behaviour,
                            indent=2, ensure_ascii=False))
                print("    âœ…ï¸ğŸ“: " + code_file_rel_path)
                return True
            else:
                print("    âŒï¸: " + code_file_rel_path)
                print_failure_details()
                return False
        else:
            equal = is_equal(real_behaviour, expected_behaviour)
            if equal:
                print("    âœ…ï¸: " + code_file_rel_path)
                return True
            else:
                real_behaviour_str = json.dumps(real_behaviour, )
                print("    âŒï¸: " + code_file_rel_path)
                print_failure_details()
                return False

    try:
        return do_test()
    except:
        print("    âŒï¸: " + code_file_rel_path)
        print_title("Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹", level=2)
        print_full_test_details_due_to_err()
        return False


def test_all(tests, syntax_only=False):
    if run("alif")[2]:
        print_err("Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù ØºÙŠØ± Ù…Ø«Ø¨Øª Ù„Ø¯ÙŠÙƒØŒ Ù‚Ù… Ø¨Ø§Ù„Ø¨Ù†Ø§Ø¡ Ø£ÙˆÙ„Ø§ Ø£Ùˆ Ù†Ø²Ù„Ù‡ Ù…Ø¨Ù†ÙŠØ§ Ø¬Ø§Ù‡Ø²Ø§")
        exit(1)

    some_failed = False

    for t in tests:
        full_path = t.get("full_path")
        for tt in t.get("tests"):
            passed = test_unit(tt, full_path, syntax_only)
            some_failed = some_failed or not passed

    if some_failed:
        print()
        print_title("Ù‚Ø¯Ø± Ø§Ù„Ù„Ù‡ ÙˆÙ…Ø§ Ø´Ø§Ø¡ ÙØ¹Ù„ØŒ Ø¨Ø¹Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù„Ù… ØªÙ†Ø¬Ø­")
        exit(1)
    else:
        print()
        print_title("Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ØŒ ØªÙ…Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¨Ù†Ø¬Ø§Ø­ ğŸ˜",
                    "Ø³Ø¨Ø­Ø§Ù†Ùƒ Ø§Ù„Ù„Ù‡Ù… ÙˆØ¨Ø­Ù…Ø¯ÙƒØŒ Ù†Ø´Ù‡Ø¯ Ø£Ù† Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø£Ù†ØªØŒ Ù†Ø³ØªØºÙØ±Ùƒ ÙˆÙ†ØªÙˆØ¨ Ø¥Ù„ÙŠÙ‡")


if __name__ == "__main__":
    is_help = sys.argv.count("--Ù…Ø³Ø§Ø¹Ø¯Ø©") > 0
    is_help = is_help or sys.argv.count("-Ù…") > 0

    if is_help:
        print_help()
        exit(0)

    is_syntax_only = sys.argv.count("--Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯-ÙÙ‚Ø·") > 0
    is_syntax_only = is_syntax_only or sys.argv.count("-Ù‚") > 0
    is_clean = sys.argv.count("--ØªØ¬Ø¯ÙŠØ¯") > 0
    is_clean = is_clean or sys.argv.count("-Ø¬") > 0
    is_fill = sys.argv.count("--ØªÙƒÙ…ÙŠÙ„") > 0
    is_fill = is_fill or sys.argv.count("-Ùƒ") > 0

    try:
        i = sys.argv.index("--Ù…Ø³Ø§Ø±")
        tests_path = sys.argv[i+1]
    except:
        try:
            i = sys.argv.index("-Ø³")
            tests_path = sys.argv[i+1]
        except:
            tests_path = path.join(__dirname__, "Ø£ÙƒÙˆØ§Ø¯")

    if not path.exists(tests_path):
        print_err(f"Ø§Ù„Ù…Ø³Ø§Ø± {tests_path} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯")
        exit(1)

    tests = get_tests(tests_path, clean=is_clean, fill=is_fill)
    test_all(tests, syntax_only=is_syntax_only)
