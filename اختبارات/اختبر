#!/usr/bin/env python

import re
import json
import subprocess
from os import sys, path, walk


__dirname__ = path.abspath(path.dirname(__file__))


def is_equal(obj1, obj2):
    e = True
    if type(obj1) == list and type(obj2) == list:
        for i in range(len(obj1)):
            if not is_equal(obj1[i], obj2[i]):
                e = False
                break
    elif type(obj1) == dict and type(obj2) == dict:
        for p in obj1:
            if not is_equal(obj1.get(p), obj2.get(p)):
                e = False
                break
    else:
        e = obj1 == obj2
    return e


def run(cmd, return_prcss=False, inputs=None):
    process = subprocess.Popen(cmd, shell=True,
                               stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if return_prcss:
        return process
    if inputs:
        stdouts = []
        stderrs = []
        for i in inputs:
            out, err = process.communicate(i.encode())
            stdouts.append(out.decode())
            stderrs.append(err.decode())
        return stdouts, stderrs, process.returncode
    out, err = process.communicate()
    return out.decode(), err.decode(), process.returncode


def get_tests(directory='Ø£ÙƒÙˆØ§Ø¯', clean=False, fill=False):
    tests = []
    tree = walk(directory)  # top-down tree
    for (full_path, dirs, files) in tree:
        alif_files = filter(lambda f: re.compile(
            r'.(Ø£Ù„Ù|alif)$').findall(f), files)
        for f in alif_files:
            name = re.compile(r'(.*)\.(?:Ø£Ù„Ù|alif)$').findall(f)[0]
            expect_file = None
            if not clean:
                expect_file = path.join(full_path, f"{name}_ØªÙˆÙ‚Ø¹.json")
                expect_file = expect_file if path.exists(expect_file) else None
            if fill and expect_file:
                continue
            code_file = path.join(full_path, f)
            t = {
                "full_path": full_path,
                "tests": [{
                    "name": name, "code_file": code_file,
                    "expect_file": expect_file}]
            }
            tests.append(t)

        if dirs:
            for d in dirs:
                sub_tests = get_tests(d)
                tests.extend(sub_tests)

    return tests


def test_unit(tt, full_path, syntax_only=False):
    SYNTAX_ONLY = "<Ù‚ÙˆØ§Ø¹Ø¯ ÙÙ‚Ø·>"
    name = tt.get('name')
    code_file = tt.get("code_file")
    expect_file = tt.get("expect_file")
    exec_file = path.join(full_path, f"{name}_ØªÙ†ÙÙŠØ°ÙŠ")
    exec_file = path.abspath(exec_file)
    log_file = path.join(full_path, f"{name}_Ø³Ø¬Ù„")

    execs_stds = None
    execs_inputs = None
    compi_inputs = None
    if expect_file:
        with open(expect_file, "r") as f:
            expected_behaviour = json.loads(f.read())
            compi_inputs = expected_behaviour.get('ØªØ¬Ù…ÙŠØ¹').get('Ø¯Ø®Ù„')
            expected_exec = expected_behaviour.get('ØªÙ†ÙÙŠØ°')
            if expected_exec and expected_exec != SYNTAX_ONLY:
                execs_inputs = map(lambda r: r.get('Ø¯Ø®Ù„'), expected_exec)
            if syntax_only:
                expected_behaviour["ØªÙ†ÙÙŠØ°"] = SYNTAX_ONLY

    syntax_only = '--syntax-only' if syntax_only else ''
    compile_stdout, compile_stderr, compile_exitcode = \
        run(f"alif '{code_file}' {syntax_only} --o '{exec_file}' --log-json '{log_file}'",
            inputs=compi_inputs)
    if not compile_exitcode and not syntax_only:
        execs_stds = \
            map(lambda i: (i, *run(f"'{exec_file}'", inputs=i)), execs_inputs) \
            if execs_inputs else [(None, *run(f"'{exec_file}'"))]

    logs = None
    if compile_exitcode:
        with open(log_file, "r") as f:
            logs = json.loads(f.read())

    real_behaviour = {
        "ØªÙ†ÙÙŠØ°": [*map(lambda stds: {
            "Ø±Ù…Ø²_Ø§Ù„Ø®Ø±ÙˆØ¬": stds[3],
            "Ø¯Ø®Ù„": stds[0],
            "Ø®Ø±Ø¬": stds[1],
            "Ø®Ø·Ø£": stds[2]
        }, execs_stds)]
        if execs_stds else SYNTAX_ONLY
        if syntax_only else None,  # if no error occured
        "ØªØ¬Ù…ÙŠØ¹": {
            "Ø±Ù…Ø²_Ø§Ù„Ø®Ø±ÙˆØ¬": compile_exitcode,
            "Ø¯Ø®Ù„": compi_inputs,
            "Ø®Ø±Ø¬": compile_stdout,
            "Ø®Ø·Ø£": compile_stderr,
            "Ø³Ø¬Ù„": logs
        }
    }

    # compare expected and real behaviours and return the state
    # of the test:
    #   - if the expect_file doesn't exists, generate it and return
    #   - if a syntax-only test was done before (compilation state only known),
    #       and now a complete test is running, test the compilation only and
    #       change the execution state if only the test pass
    #   - otherwise compare both behaviours' exec and compi behaviours

    def print_failure_details(indent="        "):
        real_behaviour_lines = json.dumps(real_behaviour,
                                        indent=2, ensure_ascii=False).split("\n")
        expected_behaviour_lines = json.dumps(expected_behaviour,
                                        indent=2, ensure_ascii=False).split("\n")
        sep = indent * 2 + "-" * 25
        print(f"{indent*2}** Ù…Ø§ Ø­Ø¯Ø« ÙØ¹Ù„Ø§ **")
        print(sep)
        print(indent + f"\n{indent}".join(real_behaviour_lines))
        print(f"{indent*2}** Ù…Ø§ ÙƒØ§Ù† Ù…ÙØªÙˆÙ‚Ø¹Ø§ **")
        print(sep)
        print(indent + f"\n{indent}".join(expected_behaviour_lines))

    if not expect_file:
        expect_file = path.join(full_path, f"{name}_ØªÙˆÙ‚Ø¹.json")
        with open(expect_file, "w") as f:
            f.write(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
        print("    ğŸ“: ", expect_file)
    elif not syntax_only and expected_behaviour.get("ØªÙ†ÙÙŠØ°") == SYNTAX_ONLY:
        equal = is_equal(real_behaviour.get("ØªØ±Ø¬Ù…Ø©"),
                         expected_behaviour.get("ØªØ±Ø¬Ù…Ø©"))
        if equal:
            with open(expect_file, "w") as f:
                f.write(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
            print("    âœ…ï¸ğŸ“: " + code_file)
            return True
        else:
            print("    âŒï¸: " + code_file)
            print_failure_details()
            return False
    else:
        equal = is_equal(real_behaviour, expected_behaviour)
        if equal:
            print("    âœ…ï¸: " + code_file)
            return True
        else:
            real_behaviour_str = json.dumps(real_behaviour, )
            print("    âŒï¸: " + code_file)
            print_failure_details()
            return False


def test_all(tests, syntax_only=False):
    if run("alif")[1]:
        print("Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù ØºÙŠØ± Ù…Ø«Ø¨Øª Ù„Ø¯ÙŠÙƒØŒ Ù‚Ù… Ø¨Ø§Ù„Ø¨Ù†Ø§Ø¡ Ø£ÙˆÙ„Ø§ Ø£Ùˆ Ù†Ø²Ù„Ù‡ Ù…Ø¨Ù†ÙŠØ§ Ø¬Ø§Ù‡Ø²Ø§\n", file=sys.stderr)
        exit(1)

    some_failed = False

    for t in tests:
        full_path = t.get("full_path")
        for tt in t.get("tests"):
            passed = test_unit(tt, full_path, syntax_only)
            some_failed = some_failed or not passed

    if some_failed:
        print()
        print("-" * 10)
        print("** Ù‚Ø¯Ø± Ø§Ù„Ù„Ù‡ ÙˆÙ…Ø§ Ø´Ø§Ø¡ ÙØ¹Ù„ØŒ Ø¨Ø¹Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù„Ù… ØªÙ†Ø¬Ø­ **")
        exit(1)


if __name__ == "__main__":
    def print_help():
        help_msg = """
        Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: Ø§Ø¬Ø±Ø§Ø¡_Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª [--Ù…Ø³Ø§Ø¹Ø¯Ø©] [--ØªÙƒÙ…ÙŠÙ„] [--Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯-ÙÙ‚Ø·] [--ØªØ¬Ø¯ÙŠØ¯]
                            [--Ù…Ø³Ø§Ø± Ù…Ø³Ø§Ø±]

        Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù„Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù.

        Ø£ÙØ³Ù’Ù†Ø§Ø¯ ØºÙŠØ± Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:
        --Ù…Ø³Ø§Ø¹Ø¯Ø©, -Ù…          Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù‡Ø°Ù‡
        --ØªÙƒÙ…ÙŠÙ„, -Ùƒ           Ø¨Ø§Ù†ØªØ§Ø¬ Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ù…Ù† Ø®Ù„Ø§Ù„ Ù…Ø§ ÙŠØ­Ø¯Ø« ÙØ¹Ù„Ø§
                                Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙˆØªÙ†ÙÙŠØ° Ø§Ù„ÙƒÙˆØ¯
        --Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯-ÙÙ‚Ø·, -Ù‚     Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø§Ù„Ø®ÙØ±Ø¬ Ø£Ùˆ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
        --ØªØ¬Ø¯ÙŠØ¯, -Ø¬           Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù†ØªØ§Ø¬ ÙƒÙ„ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ ÙˆØ¥Ù‡Ù…Ø§Ù„ Ø§Ù„Ù‚Ø¯ÙŠÙ…. Ù‡Ø°Ù‡
                                Ø§Ù„Ø£Ù…Ø± Ù„Ø§Ø¨Ø¯ Ø£Ù† ØªÙƒÙˆÙ† ÙˆØ§Ø¹ÙŠØ§ Ø¨ØªØ¨Ø¹Ø§ØªÙ‡
        --Ù…Ø³Ø§Ø± Ù…Ø³Ø§Ø±, -Ø³ Ù…Ø³Ø§Ø±  ØªØ­Ø¯ÙŠØ¯ Ù…Ø³Ø§Ø± Ù„Ø¬Ù…Ø¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù…Ù†Ù‡ ÙˆÙ…Ù† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
                                Ø¨Ø¯Ø§Ø®Ù„Ø©
        """

        print(help_msg)

    is_help = sys.argv.count("--Ù…Ø³Ø§Ø¹Ø¯Ø©") > 0
    is_help = is_help or sys.argv.count("-Ù…") > 0

    if is_help:
        print_help()
        exit(0)

    is_syntax_only = sys.argv.count("--Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯-ÙÙ‚Ø·") > 0
    is_syntax_only = is_syntax_only or sys.argv.count("-Ù‚") > 0
    is_clean = sys.argv.count("--ØªØ¬Ø¯ÙŠØ¯") > 0
    is_clean = is_clean or sys.argv.count("-Ø¬") > 0
    is_fill = sys.argv.count("--ØªÙƒÙ…ÙŠÙ„") > 0
    is_fill = is_fill or sys.argv.count("-Ùƒ") > 0

    try:
        i = sys.argv.index("--Ù…Ø³Ø§Ø±")
        tests_path = sys.argv[i+1]
    except:
        try:
            i = sys.argv.index("-Ø³")
            tests_path = sys.argv[i+1]
        except:
            tests_path = path.join(__dirname__, "Ø£ÙƒÙˆØ§Ø¯")

    if not path.exists(tests_path):
        print(f"Ø§Ù„Ù…Ø³Ø§Ø± {tests_path} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", file=sys.stderr)
        exit(1)

    tests = get_tests(tests_path, clean=is_clean, fill=is_fill)
    test_all(tests, syntax_only=is_syntax_only)