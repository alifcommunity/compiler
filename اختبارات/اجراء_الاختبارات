#!/usr/bin/env python

import re
import json
import argparse
import subprocess
from os import sys, path, walk


def is_equal(obj1, obj2):
    e = True
    if type(obj1) == list and type(obj2) == list:
        for i in range(len(obj1)):
            if not is_equal(obj1[i], obj2[i]):
                e = False
                break
    elif type(obj1) == dict and type(obj2) == dict:
        for p in obj1:
            if not is_equal(obj1.get(p), obj2.get(p)):
                e = False
                break
    else:
        e = obj1 == obj2
    return e


def run(cmd, return_prcss=False, inputs=None):
    process = subprocess.Popen(cmd, shell=True,
                               stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if return_prcss:
        return process
    if inputs:
        stdouts = []
        stderrs = []
        for i in inputs:
            out, err = process.communicate(i.encode())
            stdouts.append(out.decode())
            stderrs.append(err.decode())
        return stdouts, stderrs, process.returncode
    out, err = process.communicate()
    return out.decode(), err.decode(), process.returncode


def get_tests(directory='Ø£ÙƒÙˆØ§Ø¯', clean=False, fill=False):
    tests = []
    tree = walk(directory)  # top-down tree
    for (full_path, dirs, files) in tree:
        alif_files = filter(lambda f: re.compile(
            r'.(Ø£Ù„Ù|alif)$').findall(f), files)
        for f in alif_files:
            name = re.compile(r'(.*)\.(?:Ø£Ù„Ù|alif)$').findall(f)[0]
            expect_file = None
            if not clean:
                expect_file = path.join(full_path, f"{name}_ØªÙˆÙ‚Ø¹.json")
                expect_file = expect_file if path.exists(expect_file) else None
            if fill and expect_file:
                continue
            code_file = path.join(full_path, f)
            t = {
                "full_path": full_path,
                "tests": [{
                    "name": name, "code_file": code_file,
                    "expect_file": expect_file}]
            }
            tests.append(t)

        if dirs:
            for d in dirs:
                sub_tests = get_tests(d)
                tests.extend(sub_tests)

    return tests


def test_unit(tt, full_path, syntax_only):
    SYNTAX_ONLY = "<Ù‚ÙˆØ§Ø¹Ø¯ ÙÙ‚Ø·>"
    name = tt.get('name')
    code_file = tt.get("code_file")
    expect_file = tt.get("expect_file")
    exec_file = path.join(full_path, f"{name}_ØªÙ†ÙÙŠØ°ÙŠ")
    exec_file = path.abspath(exec_file)
    log_file = path.join(full_path, f"{name}_Ø³Ø¬Ù„")

    execs_stds = None
    execs_inputs = None
    compi_inputs = None
    if expect_file:
        with open(expect_file, "r") as f:
            expected_behaviour = json.loads(f.read())
            compi_inputs = expected_behaviour.get('ØªØ¬Ù…ÙŠØ¹').get('Ø¯Ø®Ù„')
            expected_exec = expected_behaviour.get('ØªÙ†ÙÙŠØ°')
            if expected_exec and expected_exec != SYNTAX_ONLY:
                execs_inputs = map(lambda r: r.get('Ø¯Ø®Ù„'), expected_exec)
            if syntax_only:
                expected_behaviour["ØªÙ†ÙÙŠØ°"] = SYNTAX_ONLY

    syntax_only = '--syntax-only' if syntax_only else ''
    compile_stdout, compile_stderr, compile_exitcode = \
        run(f"alif '{code_file}' {syntax_only} --o '{exec_file}' --log-json '{log_file}'",
            inputs=compi_inputs)
    if not compile_exitcode and not syntax_only:
        execs_stds = \
            map(lambda i: (i, *run(f"'{exec_file}'", inputs=i)), execs_inputs) \
            if execs_inputs else [(None, *run(f"'{exec_file}'"))]

    logs = None
    if compile_exitcode:
        with open(log_file, "r") as f:
            logs = json.loads(f.read())

    real_behaviour = {
        "ØªÙ†ÙÙŠØ°": [*map(lambda stds: {
            "Ø±Ù…Ø²_Ø§Ù„Ø®Ø±ÙˆØ¬": stds[3],
            "Ø¯Ø®Ù„": stds[0],
            "Ø®Ø±Ø¬": stds[1],
            "Ø®Ø·Ø£": stds[2]
        }, execs_stds)]
        if execs_stds else SYNTAX_ONLY
        if syntax_only else None,  # if no error occured
        "ØªØ¬Ù…ÙŠØ¹": {
            "Ø±Ù…Ø²_Ø§Ù„Ø®Ø±ÙˆØ¬": compile_exitcode,
            "Ø¯Ø®Ù„": compi_inputs,
            "Ø®Ø±Ø¬": compile_stdout,
            "Ø®Ø·Ø£": compile_stderr,
            "Ø³Ø¬Ù„": logs
        }
    }

    if not expect_file:
        expect_file = path.join(full_path, f"{name}_ØªÙˆÙ‚Ø¹.json")
        with open(expect_file, "w") as f:
            f.write(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
        print("    ğŸ“: ", expect_file)
        return

    if not syntax_only and expected_behaviour.get("ØªÙ†ÙÙŠØ°") == SYNTAX_ONLY:
        equal = is_equal(real_behaviour.get("ØªØ±Ø¬Ù…Ø©"),
                         expected_behaviour.get("ØªØ±Ø¬Ù…Ø©"))
        if equal:
            with open(expect_file, "w") as f:
                f.write(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
            print("    âœ…ï¸ğŸ“: " + code_file)
        else:
            print("    âŒï¸: " + code_file)
            print(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
        return

    equal = is_equal(real_behaviour, expected_behaviour)
    if equal:
        print("    âœ…ï¸: " + code_file)
    else:
        print("    âŒï¸: " + code_file)
        print(json.dumps(real_behaviour, indent=2, ensure_ascii=False))


def test_all(tests, syntax_only=False):
    for t in tests:
        for tt in t.get("tests"):
            test_unit(tt, t.get("full_path"), syntax_only)


if __name__ == "__main__":
    if run("alif")[1]:
        print("Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù ØºÙŠØ± Ù…Ø«Ø¨Øª Ù„Ø¯ÙŠÙƒØŒ Ù‚Ù… Ø¨Ø§Ù„Ø¨Ù†Ø§Ø¡ Ø£ÙˆÙ„Ø§ Ø£Ùˆ Ù†Ø²Ù„Ù‡ Ù…Ø¨Ù†ÙŠØ§ Ø¬Ø§Ù‡Ø²Ø§\n", file=sys.stderr)
        exit(1)

    args_parser = argparse.ArgumentParser(
        description='Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù„Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù.', add_help=False)
    args_parser.add_argument(
        "--Ù…Ø³Ø§Ø¹Ø¯Ø©", "-Ù…", help="Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù‡Ø°Ù‡", action="store_true")
    args_parser.add_argument(
        "--ØªÙƒÙ…ÙŠÙ„", "-Ùƒ", help="Ø¨Ø§Ù†ØªØ§Ø¬ Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ù…Ù† Ø®Ù„Ø§Ù„ Ù…Ø§ ÙŠØ­Ø¯Ø« ÙØ¹Ù„Ø§ Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙˆØªÙ†ÙÙŠØ° Ø§Ù„ÙƒÙˆØ¯", action="store_true")
    args_parser.add_argument(
        "--Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯-ÙÙ‚Ø·", "-Ù‚", help="Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø§Ù„Ø®ÙØ±Ø¬ Ø£Ùˆ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©", action="store_true")
    args_parser.add_argument(
        "--ØªØ¬Ø¯ÙŠØ¯", "-Ø¬", help="Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù†ØªØ§Ø¬ ÙƒÙ„ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ ÙˆØ¥Ù‡Ù…Ø§Ù„ Ø§Ù„Ù‚Ø¯ÙŠÙ…. Ù‡Ø°Ù‡ Ø§Ù„Ø£Ù…Ø± Ù„Ø§Ø¨Ø¯ Ø£Ù† ØªÙƒÙˆÙ† ÙˆØ§Ø¹ÙŠØ§ Ø¨ØªØ¨Ø¹Ø§ØªÙ‡", action="store_true")
    args_parser.add_argument(
        "--Ù…Ø³Ø§Ø±", "-Ø³", help="ØªØ­Ø¯ÙŠØ¯ Ù…Ø³Ø§Ø± Ù„Ø¬Ù…Ø¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù…Ù†Ù‡ ÙˆÙ…Ù† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ© Ø¨Ø¯Ø§Ø®Ù„Ø©", default="Ø£ÙƒÙˆØ§Ø¯")
    args = args_parser.parse_args()

    tests = get_tests(args.Ù…Ø³Ø§Ø±, clean=args.ØªØ¬Ø¯ÙŠØ¯, fill=args.ØªÙƒÙ…ÙŠÙ„)

    if (args.Ù…Ø³Ø§Ø¹Ø¯Ø©):
        help_msg = args_parser.format_help()
        help_msg = "Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…" + \
            help_msg[5:].replace("optional arguments", "Ø£ÙØ³Ù’Ù†Ø§Ø¯ ØºÙŠØ± Ø¥Ù„Ø²Ø§Ù…ÙŠØ©")
        print(help_msg)
        exit(0)

    test_all(tests, syntax_only=args.Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯_ÙÙ‚Ø·)
