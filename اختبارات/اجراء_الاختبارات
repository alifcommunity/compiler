#!/usr/bin/env python

import re
import json
import argparse
import subprocess
from os import sys, path, walk

def is_equal(dict1, dict2, msg):
    def is_dicts_equal(d1, d2):
        e = True
        for p in d1:
            p1 = d1.get(p)
            p2 = d2.get(p)
            if type(p1) == dict:
                if not is_dicts_equal(p1, p2):
                    e = False
                    break
            elif p1 != p2: 
                e = False
                break
        return e

    equal = is_dicts_equal(dict1, dict2)

    if (equal):
        msg = "    âœ…ï¸: " + msg
    else:
        msg = "    âŒï¸: " + msg

    return equal, msg


def run(cmd, return_prcss=False, inputs=None):
    process = subprocess.Popen(cmd, shell=True,
                stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if return_prcss:
        return process
    if inputs:
        stdouts = []; stderrs = []
        for i in inputs:
            out, err = process.communicate(i.encode())
            stdouts.append(out.decode());
            stderrs.append(err.decode());
        return stdouts, stderrs, process.returncode
    out, err = process.communicate()
    return out.decode(), err.decode(), process.returncode


def get_tests(directory='Ø£ÙƒÙˆØ§Ø¯', clean=False, fill=False):
    tests = []
    tree = walk(directory)  # top-down tree
    for (full_path, dirs, files) in tree:
        alif_files = filter(lambda f: re.compile(
            r'.(Ø£Ù„Ù|alif)$').findall(f), files)
        for f in alif_files:
            name = re.compile(r'(.*)\.(?:Ø£Ù„Ù|alif)$').findall(f)[0]
            expect_file = None
            if not clean:
                expect_file = path.join(full_path, f"{name}_ØªÙˆÙ‚Ø¹.json")
                expect_file = expect_file if path.exists(expect_file) else None
            if fill and expect_file: continue
            code_file = path.join(full_path, f)
            t = {
                "full_path": full_path,
                "tests": [{
                    "name": name, "code_file": code_file,
                    "expect_file": expect_file}]
            }
            tests.append(t)

        if dirs:
            for d in dirs:
                sub_tests = get_tests(d)
                tests.extend(sub_tests)

    return tests


def test_unit(tt, full_path):
    name = tt.get('name')
    code_file = tt.get("code_file")
    expect_file = tt.get("expect_file")
    exec_file = path.join(full_path, f"{name}_ØªÙ†ÙÙŠØ°ÙŠ")
    log_file = path.join(full_path, f"{name}_Ø³Ø¬Ù„")

    exec_inputs=None
    comp_inputs=None
    if expect_file:
        with open(expect_file, "r") as f:
            expected_behaviour = json.loads(f.read())
            exec_inputs = expected_behaviour.get('ØªÙ†ÙÙŠØ°').get('Ø¯Ø®Ù„')
            comp_inputs = expected_behaviour.get('ØªØ¬Ù…ÙŠØ¹').get('Ø¯Ø®Ù„')

    compile_stdout, compile_stderr, compile_exitcode = \
        run(f"alif '{code_file}' --o '{exec_file}' --log-json '{log_file}'", inputs=comp_inputs)
    if not compile_exitcode:
        stdout, stderr, exitcode = \
            run(f"./'{exec_file}'", inputs=exec_inputs)

    logs = None
    if compile_exitcode:
        with open(log_file, "r") as f:
            logs = json.loads(f.read())

    real_behaviour = {
        "ØªÙ†ÙÙŠØ°": {
            "Ø±Ù…Ø²_Ø§Ù„Ø®Ø±ÙˆØ¬": exitcode,
            "Ø¯Ø®Ù„": exec_inputs,
            "Ø®Ø±Ø¬": stdout,
            "Ø®Ø·Ø£": stderr
        } if not compile_exitcode else None, # if no error occured
        "ØªØ¬Ù…ÙŠØ¹": {
            "Ø±Ù…Ø²_Ø§Ù„Ø®Ø±ÙˆØ¬": compile_exitcode,
            "Ø¯Ø®Ù„": comp_inputs,
            "Ø®Ø±Ø¬": compile_stdout,
            "Ø®Ø·Ø£": compile_stderr,
            "Ø³Ø¬Ù„": logs
        }
    }

    if not expect_file:
        expect_file = path.join(full_path, f"{name}_ØªÙˆÙ‚Ø¹.json")
        with open(expect_file, "w") as f:
            f.write(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
        print("    ğŸ“: ", expect_file)
        return

    equal, msg = is_equal(real_behaviour, expected_behaviour, code_file)
    print(msg)
    if not equal:
        print(json.dumps(real_behaviour, indent=2, ensure_ascii=False))


def test_all(tests, syntax_only=False):
    for t in tests:
        for tt in t.get("tests"):
            test_unit(tt, t.get("full_path"))


if __name__ == "__main__":
    if run("alif")[1]:
        sys.stderr.write(
            "Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù ØºÙŠØ± Ù…Ø«Ø¨Øª Ù„Ø¯ÙŠÙƒØŒ Ù‚Ù… Ø¨Ø§Ù„Ø¨Ù†Ø§Ø¡ Ø£ÙˆÙ„Ø§ Ø£Ùˆ Ù†Ø²Ù„Ù‡ Ù…Ø¨Ù†ÙŠØ§ Ø¬Ø§Ù‡Ø²Ø§\n")
        exit(1)

    args_parser = argparse.ArgumentParser(
        description='Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù„Ù…ØªØ±Ø¬Ù… Ø£Ù„Ù.', add_help=False)
    args_parser.add_argument(
        "--Ù…Ø³Ø§Ø¹Ø¯Ø©", "-Ù…", help="Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ù… Ù‡Ø°Ù‡", action="store_true")
    args_parser.add_argument(
        "--ØªÙƒÙ…ÙŠÙ„", "-Ùƒ", help="Ø¨Ø§Ù†ØªØ§Ø¬ Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©", action="store_true")
    args_parser.add_argument(
        "--Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯-ÙÙ‚Ø·", "-Ù‚", help="Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø§Ù„Ø®ÙØ±Ø¬", action="store_true")
    args_parser.add_argument(
        "--ØªØ¬Ø¯ÙŠØ¯", "-Ø¬", help="Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù†ØªØ§Ø¬ ÙƒÙ„ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ ÙˆØ¥Ù‡Ù…Ø§Ù„ Ø§Ù„Ù‚Ø¯ÙŠÙ…. Ù‡Ø°Ù‡ Ø§Ù„Ø£Ù…Ø± Ù„Ø§Ø¨Ø¯ Ø£Ù† ØªÙƒÙˆÙ† ÙˆØ§Ø¹ÙŠØ§ Ø¨ØªØ¨Ø¹Ø§ØªÙ‡", action="store_true")
    args = args_parser.parse_args()

    tests = get_tests(clean=args.ØªØ¬Ø¯ÙŠØ¯, fill=args.ØªÙƒÙ…ÙŠÙ„)

    if (args.Ù…Ø³Ø§Ø¹Ø¯Ø©):
        help_msg = args_parser.format_help()
        help_msg = "Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…" + \
            help_msg[5:].replace("optional arguments", "Ø£ÙØ³Ù’Ù†Ø§Ø¯ ØºÙŠØ± Ø¥Ù„Ø²Ø§Ù…ÙŠØ©")
        print(help_msg)
        exit(0)

    test_all(tests, syntax_only=args.Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯_ÙÙ‚Ø·)
